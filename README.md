なぜ再ハッシュより木構造の方が良いか？

- 再ハッシュに毎回労力がかかる。木ならちょっとずらすだけでよい。
- しかもリストの中に単語がある分、O(N)かかる
- Nを予想できないとなると最初からちょうどよいサイズのハッシュテーブルを作っておくこともできない。
- Nが大きくなるとハッシュテーブルの大きさとして使える素数の個数が減っていく。大きい数字の方が約数を持つ可能性が増え、素数の密度が小さいから。→素数じゃなくても大丈夫。ハッシュ値自体がそもそも素数だから。
- 最悪のケースのときハッシュはO(N)だけど木構造はO(logN)
- 木構造ではそもそも衝突がない。メモリをくわない。必要な量だけの計算量で動く。
- ハッシュは数字に変換されているから、ランダムで範囲が設定できない。ソートとかもできない。
- 木構造はハードディスクに保存できるが、ハッシュテーブルは向いていない。ランダムにハードディスクの中から探すのが困難。

宿題3

- キャッシュへアクセスし、追加削除もできる必要がある。
- キャッシュ自体をそれぞれハッシュ化する。
- 最近使った順にソートする？ 
- そうするとハッシュ値と利用された時間帯と2つの要素を持たせないといけないのでは？

6/6追加
- 宿題1で作ったハッシュテーブルと連結リストを使う
- Nodeクラスを作ってurlとcontentの情報を持ったノードを定義する。
-   双方向にするためにprevとnextをもつようにする
- ハッシュテーブルでノードとURLを対応させる。
- ページにアクセスされたら、すでにキャッシュにある場合、ノードを一度削除して新しくリストの先頭に追加。
- キャッシュにない新しいページの場合リストの先頭にノードを追加して一番末尾にあるものを削除
- get pagesではキャッシュのなかにあるurlを取得してリストで返す
- リストの先頭と末尾に空のノードを準備してリストの中に何もなくならないようにした。
